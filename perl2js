#!/usr/bin/perl

## rules of thumb
# no regex should contain a .
# most should be non-greedy

undef $/;

$source = join ('', <>);


## swap over functions with params
$source =~ s/
	(sub\s+)          # 1 sub
	(\w+?)            # 2 function
	(\s*{\s*)         # 3 {
	(my\s*)           # 4 my
	(\()              # 5 (
	([\$\w\s\,]*?)    # 6 $args    Can be $ letters or ,
	(\))              # 7 )
	(\s*=\s*\@_;)     # 8 = @_; 
	/function $2($6)$3/gmsx;

## swap over functions with no params
$source =~ s/
	(sub\s)           # 1 sub
	(\w+?)            # 2 function
	(\s*{\s*)         # 3 {
	/function $2()$3/gmsx;


## swap my for var
$source =~ s/
	(my)              # 1 my
	(\s+?)            # 2 
	/var$2/gmsx;



## swap my for var
$source =~ s/
	(\n\s*)           # 1
	(print)           # 2 print
	(.+?)             # 3 something
	(;)               # 4;
	/$1document.write($3 )$4/gmsx;



# swap out some escaped chars with unicode equivalents to keep it safe and easy for the other regex's
$source =~ s/\\\"/\\u0022/gmsx;
$source =~ s/\\\$/\\u0024/gmsx;


## swap variables inside " strings

sub replace_vars {
	($in) = @_;
	$in =~ s/
		(\$)              # 1 $
		(\w+)             # 2 var
		(\W|$)            # 3 stuff or end of line
		/\"+$1$2+\"$3/gmsx;
	return "\"$in\"";
}

$source =~ s/
	(")               # 1 "
	([^"]*)           # 2 stuff that ain't a "
	(")               # 3 "
	/replace_vars($2)/egmsx;






# swap join

# swap substring

# swap regex?




# remove trailing 1;
$source =~ s/1;$//g;


print $source;

